###########################################################################################
#
# Barebones of continuous integration in stages
#
# Much, much room for optimization and bringing closer to the real world
#
# 1. Check the build
# 2. Test the api
# 3. Publish the api
# 4. Deploy the api to azure
#
# See README.md for further details
#
#
# TRACEABILITY
#
#   A crude approach where steps dump output is the traceability of the moment.
#   OpenTelemetry looks interesting, but is beyond scope for noe
#

name: LabDemo.MinimalApi.BuildByStages
run-name: ${{ github.actor }} is experimenting with GitHub actions 🚀
on: [push]

env:    
    SOLUTION: LabDemo.MinimalApi
    PROJECT: LabDemo.MinimalApi
    TEST_PROJECT: LabDemo.MinimalApi.Tests
    NUGET_SOURCE: https://api.nuget.org/v3/index.json
    NUGET_PATH: nuget
    BUILD_ARTIFACT_NAME: build
    PUBLISH_ARTIFACT_NAME: publish
    BUILD_PATH: build
    PUBLISH_PATH: publish
    VALIDATE: true

jobs:

  #============================================================
  #  BUILD STAGE
  #
  #  Ensures that the solution builds without errors with each push to the remote repo
  #  Restores external dependencies and builds the API
  #  Caching nuget dependencies is a bit overkill for a small project, but
  #  good practice
  #
  #  A nuget.config file has been added to the solution, which will hopefully 
  #  direct all dotnet CLI steps to the appropriate source and package directory
  #
  #  The path of 'nuget' is synchronized with the ci bash shell script included in
  #  the solution; the ci script can be used to emulate the steps taken here, emulating
  #  in the local environment
  
  build:
    name: Build API
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:       
       
    - name: Checkout
      uses: actions/checkout@v3

    - name: Cache the nuget
      id: cache-nuget
      uses: actions/cache@v3
      with:
        path: nuget
        key: nuget-${{ hashFiles('*/*.csproj')}}

    - name: Install dependencies
      if: steps.cache-nuget.outpus.cache-hit != true
      run: dotnet restore

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Build just the API subsystem
      run: dotnet build $PROJECT/$PROJECT.csproj -c Release --no-incremental -o $BUILD_PATH

    - name: Validate directory state
      run: |
        du -sh ./*

    # artifacts are overkill for this small of project, but done as a 
    # poc and best practice for larger systems

    - name: Upload artifact for test and publish jobs
      uses: actions/upload-artifact@v3
      with:
        name: ${{env.BUILD_ARTIFACT_NAME}}
        path: ${{env.BUILD_PATH}}
        retention-day: 1
        
  ##============================================================
  ##  TEST STAGE
  ##
  
  test:
    name: API Black-Box Testing
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    needs: [build]       
    steps:     

    - name: Checkout
      uses: actions/checkout@v3

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Nuget from cache
      id: cache-nuget
      uses: actions/cache@v3
      with:
        path: nuget
        key: nuget-${{ hashFiles('*/*.csproj')}}

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Download artifact from build job
      uses: actions/download-artifact@v3

    - name: Validate directory state
      run: |
        du -sh ./*

    # artifacts are overkill for this small of project, but done as a 
    # poc and best practice for larger systems

    - name: Test the api
      run: |
        pwd
        du -sh .
        dotnet test $TEST_PROJECT/$TEST_PROJECT.csproj -c Release -o $BUILD_PATH

    - name: Validate directory state
      run: |
        du -sh ./*

  #============================================================
  #  PUBLISH STAGE

  publish:
    name: Publish the API
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    needs: [test]    
    steps:

    - name: Checkout
      uses: actions/checkout@v3

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Nuget from cache
      id: cache-nuget
      uses: actions/cache@v3
      with:
        path: nuget
        key: nuget-${{ hashFiles('*/*.csproj')}}

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Download artifact from build job
      uses: actions/download-artifact@v3

    - name: Validate directory state
      run: |
        du -sh ./*

    # artifacts are overkill for this small of project, but done as a 
    # poc and best practice for larger systems

    - name: Publish the api
      run: dotnet publish $PROJECT/$PROJECT.csproj -c Release -p:OutDir=$BUILD_PATH -o $PUBLISH_PATH

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Upload artifact for deployment
      uses: actions/upload-artifact@v3
      with:
        name: ${{env.PUBLISH_ARTIFACT_NAME}}
        path: ${{env.PUBLISH_PATH}}
        retention-day: 3

  #============================================================
  #  DEPLOY STAGE
  #

  deploy_azure:
    name: Manually deploy to Azure
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    needs: [publish]    
    steps:

    - name: Download artifact from publish job
      uses: actions/download-artifact@v3
      with:
        name: ${{env.PUBLISH_ARTIFACT_NAME}}

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Placeholder
      run: |
        echo "TBD Deploy"
