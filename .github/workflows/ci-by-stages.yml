###########################################################################################
#
# Barebones of continuous integration in stages
#
# Much, much room for optimization and bringing closer to the real world
#
# 1. Check the build
# 2. Test the api
# 3. Publish the api
# 4. Deploy the api to azure
#
# See README.md for further details
#
#
# TRACEABILITY
#
#   A crude approach where steps dump output is the traceability of the moment.
#   OpenTelemetry looks interesting, but is beyond scope for noe
#

name: LabDemo.MinimalApi.BuildByStages
run-name: ${{ github.actor }} is experimenting with GitHub actions 🚀
on: [push]

env:    
    PROJECT: LabDemo.MinimalApi
    TEST_PROJECT: LabDemo.MinimalApi.Tests
    BUILD_ARTIFACT_NAME: build
    PUBLISH_ARTIFACT_NAME: publish
    BUILD_PATH: build
    PUBLISH_PATH: publish
    BUILD_CACHE: ${PROJECT}/${PROJECT}.csproj
    TMP: ${{ always() && hashFiles(env.BUILD_CACHE)}}
    BUILD_CACHE_KEY: nuget-$TMP


jobs:

  #============================================================
  #  BUILD STAGE
  #
  #  Ensures that the solution builds without errors with each push to the remote repo
  #  Restores external dependencies and builds the API
  #  Caching nuget dependencies is a bit overkill for a small project, but
  #  good practice
  #
  #  A nuget.config file has been added to the solution, which will hopefully 
  #  direct all dotnet CLI steps to the appropriate source and package directory
  #
  #  The path of 'nuget' is synchronized with the ci bash shell script included in
  #  the solution; the ci script can be used to emulate the steps taken here, emulating
  #  in the local environment
  
  build:
    name: Build API
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:       
       
    - name: Checkout
      uses: actions/checkout@v3

    - name: Check key
      run: |
        echo $BUILD_CACHE_KEY
        echo ${{env.BUILD_CACHE_KEY}}

    - name: Cache the nuget for the app project
      id: cache-nuget
      uses: actions/cache@v3
      with:
        path: nuget
        key: ${{env.BUILD_CACHE_KEY}}

    - name: Install dependencies
      if: steps.cache-nuget.outpus.cache-hit != true
      run: dotnet restore

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Build just the API subsystem
      run: dotnet build $PROJECT/$PROJECT.csproj -c Release --no-incremental -o $BUILD_PATH

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Upload artifact for test and publish jobs
      uses: actions/upload-artifact@v3
      with:
        name: ${{env.BUILD_ARTIFACT_NAME}}
        path: ${{env.BUILD_PATH}}
        retention-days: 1
        
  ##============================================================
  ##  TEST STAGE
  ##
  
  test:
    name: API Black-Box Testing
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    needs: [build]       
    steps:     

    - name: Checkout
      uses: actions/checkout@v3

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Nuget from cache
      id: cache-nuget
      uses: actions/cache@v3
      with:
        path: nuget
        key: ${{env.BUILD_CACHE_KEY}}

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Download artifact from build job
      uses: actions/download-artifact@v3

    - name: Validate directory state
      run: |
        du -sh ./*

    # artifacts are overkill for this small of project, but done as a 
    # poc and best practice for larger systems

    - name: Test the api
      run: |
        pwd
        du -sh .
        dotnet test $TEST_PROJECT/$TEST_PROJECT.csproj -c Release -o $BUILD_PATH

    - name: Validate directory state
      run: |
        du -sh ./*

  #============================================================
  #  PUBLISH STAGE

  publish:
    name: Publish the API
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    needs: [test]    
    steps:

    - name: Checkout
      uses: actions/checkout@v3

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: App's nuget from cache
      id: cache-nuget
      uses: actions/cache@v3
      with:
        path: nuget
        key: ${{env.BUILD_CACHE_KEY}}

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Download artifact from build job
      uses: actions/download-artifact@v3

    - name: Validate directory state
      run: |
        du -sh ./*

    # artifacts are overkill for this small of project, but done as a 
    # poc and best practice for larger systems

    - name: Publish the api
      run: dotnet publish $PROJECT/$PROJECT.csproj -c Release -p:OutDir=$BUILD_PATH -o $PUBLISH_PATH

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Upload artifact for deployment
      uses: actions/upload-artifact@v3
      with:
        name: ${{env.PUBLISH_ARTIFACT_NAME}}
        path: ${{env.PUBLISH_PATH}}
        retention-days: 1

  #============================================================
  #  AZURE DEPLOY
  #
  #  Requires both an app service and an API service pre-configured, and the names must
  #  match

  deploy_azure:
    name: Manually deploy to Azure
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    # this relies on GitHub settings for the production environment
    # that require manual approval before deployment

    environment:
      name: production

    needs: [publish]    
    steps:

    - name: Download artifact from publish job
      uses: actions/download-artifact@v3
      with:
        name: ${{env.PUBLISH_ARTIFACT_NAME}}

    - name: Validate directory state
      run: |
        du -sh ./*

    - name: Deploy to Azure Web App
      id: deploy-to-webapp
      uses: azure/webapps-deploy@v3
      with:
        app-name: 'LabDemo-MinimalApi-Code'
        slot-name: 'Production'
        publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_FEB370F5C81A4C1EBA8D302EC1CB0084 }}
        package: .