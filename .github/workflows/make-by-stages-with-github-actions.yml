###########################################################################################
#
# Barebones of continuous integration in stages
#
# Much, much room for optimization and bringing closer to the real world
#
# PATHING
#   Note if an app's project name is the same as a solution name, it can be confusing
#
#   GitHub checks out the repo into `/home/runner/work/{GithubProjectName}/{YourRepoName}`
#
#   So, this could lead to building a project of the same name in a directory like
#       `/home/runner/work/TheLarryApp/TheLarryApp/TheLarryApp`
#
#   Matching the `/home/runner/work/{GithubProjectName}` supplied by the GitAction checkout
#       then the repo name, `/home/runner/work/{GitHubProjectName}/{YourRepoName}` where the sln lives
#       then perhaps the project, `/home/runner/work/{GitHubProjectName}/{YourRepoName}/{YourProjectName}`
#           containing `csproj`
#
# DEPENDENCIES
#
#   When trying to leverage dependencies collected in a previous dotnet step, the only way to confirm that the 
#   current dotnet step is pointed at those existing dependencies is VISUAL INSPECTION.  So far, I have not 
#   identified any other way

name: LabDemo.MinimalApi.BuildByStages
run-name: ${{ github.actor }} is experimenting with GitHub actions 🚀
on: [push]

env:
    SOLUTION: LabDemo.MinimalApi
    PROJECT: LabDemo.MinimalApi

jobs:

  #============================================================
  #  BUILD STAGE
  #
  # Ensures that the code builds without errors with each push to the remote repo
  #

  build:
    name: Build API

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    runs-on: ubuntu-latest
    strategy:
      matrix:
        dotnet-version: ['7.x.x' ]

    steps:       
    - name: Checkout
      uses: actions/checkout@v3

    - name: Set up .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ matrix.dotnet-version }}

    - name: Before
      run: |
        echo "SOLUTION = $SOLUTION"
        echo "PROJECT = $PROJECT"
        echo "Total solution storage consumption before job for ${PWD}:" 
        du -sh ./*

    # rely on dotnet build to restore any nuget dependencies for the app itself
    # 1. It's a small app, so not a large number of nuget packages to concern one's self with, or to cache for later
    # 2. The only purpose of a separate restore step would be to direct to a custom directory
    #    to store in the cache for later use with other projects in the solution later
    # 3. Custom directories for dotnet steps are PROBLEMATIC for a number of reasons -- avoid when you can

    - name: Build the project
      run: |        
        cd $PROJECT
        dotnet build -c Release --no-incremental -o ../build

    - name: Pass the build on to the publish step 
      uses: actions/upload-artifact@v3
      with:
        name: api-build-output
        path: ./build
        retention-days: 1

    - name: After
      run: |
        echo "Total solution storage consumption before job for ${PWD}:" 
        du -sh ./*
        
  #============================================================
  #  TEST STAGE

  test:
    name: API Black-Box Testing

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    runs-on: ubuntu-latest

    strategy:
      matrix:
        dotnet-version: ['7.x.x' ]

    needs: [build]    
    
    env:
      TEST_PROJECT: LabDemo.MinimalApi.Tests

    steps:

    - name: Checkout
      uses: actions/checkout@v3
      
    - name: Set up .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ matrix.dotnet-version }}

    - name: Before
      run: |
        echo "SOLUTION = $SOLUTION"
        echo "TEST_PROJECT = $TEST_PROJECT"
        echo "Running in ${PWD}"
        echo "Total solution storage consumption before job for ${PWD}:" 
        du -sh ./*
        
    # The -o parameter tells dotnet test where to find the TEST binaries for the app to run, 
    # not where the app binaries are from the build step, and not where the test output is going 
    # (test output goes to the specificed --results-directory <blah> or to the default TestResults)

    - name: Run the black box tests
      run: |
        cd $TEST_PROJECT
        dotnet test -c Release

    - name: After
      run: |
        echo "Total solution storage consumption after job for ${PWD}:" 
        du -sh ./*

  #============================================================
  #  PUBLISH STAGE

  publish:
    name: Publish the API

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    runs-on: ubuntu-latest

    strategy:
      matrix:
        dotnet-version: ['7.x.x' ]

    needs: [build, test]    
        
    steps:

    - name: Checkout
      uses: actions/checkout@v3

    - name: Set up .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ matrix.dotnet-version }}

    - name: Download api build artifacts for speed optimization
      uses: actions/download-artifact@v3
      with: 
        name: api-build-output
        path: build

    - name: Check artifact download
      run: |
        echo "default working directory, ${PWD}:"
        ls
        echo "and in the build dir:"
        ls build

    # Optimized by using the output from the previous build job, which includes
    # not only the nuget dependencies, but the binaries for the api

    - name: Publish the API
      run: |
        echo "default working directory, ${PWD}"
        echo "PROJECT = ${PROJECT}"
        cd $PROJECT
        echo "project now working directory, ${PWD}"
        ls ../build
        dotnet publish -c Release -o ../publish --source ../build

    - name: After
      run: |
        echo "Total solution storage consumption before job for ${PWD}:" 
        du -sh ./*

    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v2
      with:
        name: ${PROJECT}
        path: ../publish

  #============================================================
  #  DEPLOY STAGE

  deploy-azure:
    name: Deploy to Azure

    defaults:
      run:
        shell: bash
#        working-directory: .

    runs-on: ubuntu-latest

    needs: [publish]    

    environment:
      name: 'production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v2
        with:
          name: ${PROJECT}

      - name: Deploy to Azure Web App
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: 'LabDemo-MinimalApi-Code'
          slot-name: 'production'
          publish-profile: ${{ secrets.AzureAppService_PublishProfile_a3c3d11e8d764bfdbf88856aa7a173c4 }}
          package: .