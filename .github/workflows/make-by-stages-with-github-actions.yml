###########################################################################################
#
# Barebones of continuous integration in stages
#
# Much, much room for optimization and bringing closer to the real world
#
# PATHING
#   Note if an app's project name is the same as a solution name, it can be confusing
#
#   GitHub checks out the repo into `/home/runner/work/{GithubProjectName}/{YourRepoName}`
#
#   So, this could lead to building a project of the same name in a directory like
#       `/home/runner/work/TheLarryApp/TheLarryApp/TheLarryApp`
#
#   Matching the `/home/runner/work/{GithubProjectName}` supplied by the GitAction checkout
#       then the repo name, `/home/runner/work/{GitHubProjectName}/{YourRepoName}` where the sln lives
#       then perhaps the project, `/home/runner/work/{GitHubProjectName}/{YourRepoName}/{YourProjectName}`
#           containing `csproj`
#
# DOTNET AND CI OPTIMIZATION INCOMPATIBILITY
#
#   In theory, one could restore nuget dependencies once at the beginning, then use throughout ci steps
#   In theory, one could store results of the dotnet build in a custom directory and use in successive commands
#
#   In reality, the dotnet commands are not built to be used in this manner, and it's very difficult to set up
#   cache with nuget dependencies, temporary artifacts from the build, successive ci steps using said cache and
#   artifacts, and CONFIRMING that the setup is working as expected and that successive dotnet commands are not
#   just rebuilding the whole darn thing agin.
#
#   But, this ci attempts to do so, because the authoring engineer is stubborn, er, persistent
#
# TRACEABILITY
#
#   A crude approach where steps dump output is the traceability of the moment.
#   OpenTelemetry looks interesting, but is beyond scope for noe
#

name: LabDemo.MinimalApi.BuildByStages
run-name: ${{ github.actor }} is experimenting with GitHub actions 🚀
on: [push]

# The NUGET_KEY is flexible; for instance, examples exist to make it update when package-lock.json changes, but
# note by default .NET projects do not typically use the package lock file, so that condition would always be met
# for this project BUT right now, interpolation isn't working such that we can set a global key variable (see below)
#
# Another option would be to detect changes to the .csproj file, then update the cache based on that, but for
# this case, the commit SHA should be enough, although not all that sophisticated.  Sometimes good enough is good
# enough

# *** GLOBAL ENVIRONMENT VARIABLES MUST BE VALUE OR VALUE COMBOS ONLY
#
# Shell parameter expansion is not possible outside of a run step, so global environment variables are really
# just for values for now
#
# Instead, we can 
#     1) For variables to passed from one step to another in the same job, 
#       append variables assigned via parameter expansion to the GitHub environment file
#       per https://stackoverflow.com/questions/60432844/how-to-perform-string-manipulation-while-declaring-env-vars-in-github-actions
#     2) For variables passed to the next job, use job output https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs

env:    
    SOLUTION: LabDemo.MinimalApi
    PROJECT: LabDemo.MinimalApi
    TEST_PROJECT: LabDemo.MinimalApi.Tests
    NUGET_SOURCE: https://api.nuget.org/v3/index.json
    NUGET_PATH: nuget

jobs:

  #============================================================
  #  API DEPENDENCIES STAGE
  #
  #  Loads external dependencies for the API into the cache
  #

  restore:
    name: Load app package dependencies

    defaults:
      run:
        shell: bash

    runs-on: ubuntu-latest
    strategy:
      matrix:
        dotnet-version: ['7.x.x' ]

    outputs:
      cache-key: ${{steps.cache-key.outputs.test}}

    steps:       
    - name: Checkout
      uses: actions/checkout@v3

    - name: Set up .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ matrix.dotnet-version }}

    - name: Before
      run: |
        echo "SOLUTION = $SOLUTION"
        echo "PROJECT = $PROJECT"
        echo "NUGET CACHE KEY = $GITHUB_SHA"
        echo "NUGET_SOURCE = $NUGET_SOURCE"
        echo "NUGET PATH = $NUGET_PATH"
        echo "Total solution storage consumption before job for ${PWD}:" 
        du -sh ./*

    # This approaches overrides any settings in nuget.config if it exists
    # This approach retrieves all dependencies for the solution; see the ci script for more details

    - name: Load
      run: |
        dotnet restore --source $NUGET_SOURCE --packages $NUGET_PATH
        du -sh $NUGET_PATH

    - name: Cache .NET packages
      id: cache-nuget
      uses: actions/cache@v3
      with:
        path: nuget
        key: $GITHUB_SHA

    - name: Preserve key for later use
      id: cache-key
      run: echo "NUGET_CACHE_KEY=" + $GITHUB_SHA >> $GITHUB_OUTPUT

  #============================================================
  #  BUILD STAGE
  #
  # Ensures that the code builds without errors with each push to the remote repo
  #

  build:
    name: Build API

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    runs-on: ubuntu-latest
    strategy:
      matrix:
        dotnet-version: ['7.x.x' ]

    needs: [restore]    

    steps:       
    - name: Checkout
      uses: actions/checkout@v3

    - name: Set up .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ matrix.dotnet-version }}

    - name: Before
      run: |
        echo "SOLUTION = $SOLUTION"
        echo "PROJECT = $PROJECT"
        echo "Total solution storage consumption before job for ${PWD}:" 
        du -sh ./*
        echo "KEY=" + ${{needs.test.outputs.cache-key}}

    - name: Restore Nuget cache
      id: cache-restore
      uses: actions/cache@v3
      with:
        path: $NUGET_PATH
        key: ${{needs.test.outputs.cache-key}}

    - name: Build the project with cached nuget
      if: steps.cache-restore.outputs.cache-hit == 'true'              
      run: |        
        dotnet build $PROJECT/${PROJECT}.csproj -c Release --no-incremental --no-restore --source ./$NUGET_PATH -o ./buildtest

    - name: Build the project without cache
      if: steps.cache-restore.outputs.cache-hit == 'false'              
      run: |        
        dotnet build $PROJECT/${PROJECT}.csproj -c Release --no-incremental --source ./$NUGET_SOURCE -o ./buildtest

    - name: Pass the build on to the publish step 
      uses: actions/upload-artifact@v3
      with:
        name: api-build-output
        path: ./build
        retention-days: 1

    - name: After
      run: |
        echo "Total solution storage consumption before job for ${PWD}:" 
        du -sh ./*
        
  ##============================================================
  ##  TEST STAGE
  ##
  
  #test:
  #  name: API Black-Box Testing

  #  # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
  #  defaults:
  #    run:
  #      shell: bash

  #  runs-on: ubuntu-latest

  #  strategy:
  #    matrix:
  #      dotnet-version: ['7.x.x' ]

  #  needs: [build]    
    
  #  steps:

  #  - name: Checkout
  #    uses: actions/checkout@v3
      
  #  - name: Set up .NET Core
  #    uses: actions/setup-dotnet@v3
  #    with:
  #      dotnet-version: ${{ matrix.dotnet-version }}

  #  - name: Before
  #    run: |
  #      echo "SOLUTION = $SOLUTION"
  #      echo "TEST_PROJECT = $TEST_PROJECT"
  #      echo "Running in ${PWD}"
  #      echo "Total solution storage consumption before job for ${PWD}:" 
  #      du -sh ./*

  #  - name: Restore Nuget cache
  #    id: cache-restore
  #    uses: actions/cache@v3
  #    with:
  #      path: $NUGET_PATH
  #      key: ${NUGET_CACHE_KEY}
        
  #  # The -o parameter tells dotnet test where to find the TEST binaries for the app to run, 
  #  # not where the app binaries are from the build step, and not where the test output is going 
  #  # (test output goes to the specificed --results-directory <blah> or to the default TestResults)

  #  # also, currently, can't find documentation to pass the right argument for the dotnet test to use
  #  # the nuget dependencies restored in the first ci step, BUT I think something's happening 
  #  # "under the hood" such that the "no-restore" means it found the nuget directory somehow??

  #  - name: Test the project with cached nuget
  #    if: steps.cache-restore.outputs.cache-hit == 'true'              
  #    run: |        
  #      dotnet test $TEST_PROJECT/${TEST_PROJECT}.csproj -c Release --no-restore -o buildtest

  #  - name: Test the project without cache
  #    if: steps.cache-restore.outputs.cache-hit == 'false'              
  #    run: |        
  #      dotnet test $TEST_PROJECT/${TEST_PROJECT}.csproj -c Release -o buildtest

  #  - name: After
  #    run: |
  #      echo "Total solution storage consumption after job for ${PWD}:" 
  #      du -sh ./*

  ##============================================================
  ##  PUBLISH STAGE

  #publish:
  #  name: Publish the API

  #  # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
  #  defaults:
  #    run:
  #      shell: bash

  #  runs-on: ubuntu-latest

  #  strategy:
  #    matrix:
  #      dotnet-version: ['7.x.x' ]

  #  needs: [build, test]    
        
  #  steps:

  #  - name: Checkout
  #    uses: actions/checkout@v3

  #  - name: Set up .NET Core
  #    uses: actions/setup-dotnet@v3
  #    with:
  #      dotnet-version: ${{ matrix.dotnet-version }}

  #  - name: Before
  #    run: |
  #      echo "Total solution storage consumption before job for ${PWD}:" 
  #      du -sh ./*

  #  - name: Restore Nuget cache
  #    id: cache-restore
  #    uses: actions/cache@v3
  #    with:
  #      path: $NUGET_PATH
  #      key: ${NUGET_CACHE_KEY}

  #  - name: Download api build artifacts for speed optimization
  #    uses: actions/download-artifact@v3
  #    with: 
  #      name: api-build-output
  #      path: build

  #  - name: Check artifact download
  #    run: |
  #      echo "default working directory, ${PWD}:"
  #      ls
  #      echo "and in the build dir:"
  #      ls build

  #  - name: After cache and artifacts
  #    run: |
  #      echo "Total solution storage consumption after cache and artifacts for ${PWD}:" 
  #      du -sh ./*

  #  - name: Publish the project with cache and artifacts
  #    run: |        
  #      dotnet publish $PROJECT/${PROJECT}.csproj -c Release --no-build -p:OutDir=../buildtest -o ./publish

  #  - name: After
  #    run: |
  #      echo "Total solution storage consumption before job for ${PWD}:" 
  #      du -sh ./*

  #  - name: Upload artifact for deployment job
  #    uses: actions/upload-artifact@v2
  #    with:
  #      name: ${PROJECT}
  #      path: ../publish

  ##============================================================
  ##  DEPLOY STAGE

  #deploy-azure:
  #  name: Deploy to Azure

  #  defaults:
  #    run:
  #      shell: bash

  #  runs-on: ubuntu-latest

  #  needs: [publish]    

  #  environment:
  #    name: 'production'
  #    url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

  #  steps:
  #    - name: Download artifact from build job
  #      uses: actions/download-artifact@v2
  #      with:
  #        name: ${PROJECT}

  #    - name: Deploy to Azure Web App
  #      id: deploy-to-webapp
  #      uses: azure/webapps-deploy@v2
  #      with:
  #        app-name: 'LabDemo-MinimalApi-Code'
  #        slot-name: 'production'
  #        publish-profile: ${{ secrets.AzureAppService_PublishProfile_a3c3d11e8d764bfdbf88856aa7a173c4 }}
  #        package: .